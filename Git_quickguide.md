# **Git краткое руководство**



## Основы



Git - это набор консольных утилит, которые отслеживают и фиксируют изменения в файлах (чаще в исходном коде программ). 
Изначально Git был создан Линусом Торвальдсом при разработке ядра Linux.
Git нужен,  чтобы отследить изменения, произошедшие с проектом во времени. Он также чрезвычайно полезен при одновременной работе над одним проектом.

## Установка


Linux 

`sudo apt-get install git`


Windows 

`git для windows `


OS X 

`brew install git`


## Настройка


После установки git, нужно добавить несколько настроек. 


`git config --global user.name "My Name"`

`git config --global user.email myEmail@example.com`

Если есть необходимость, для конкретного проекта поменять автора, нужно убрать флаг --global. Настройка будет действовать только для текущего проекта.

таким образом все будут знать кто, где и когда вносил изменения.
Впрочем, если вы укажите фиктивные данные - это вас не спасёт. 
Честность всегда приветствуется. 


Все настройки системы


`git config --list`


`git --help `


Общая документация по git


`log --help`

хелп по команде (в данном случае это - log)


Если вы вдруг сделали опечатку - система подскажет вам нужную команду
После выполнения любой команды - отчитается о том, что вы натворили
Также Гит прогнозирует дальнейшие варианты развития событий и всегда направит разработчика, не знающего, куда двигаться дальше


## Создание нового репозитория


`git init`


Initialized empty Git repository in /home/user/Desktop/git_exercise/.git/

Репозиторий был успешно создан, но пока что пуст. 

После этого будет создана папка .git в текущей папке терминала.

.git — это папка, которая хранит всю информацию о гит репозитории. Если ее удалять, то будет утеряна вся информация о репозитарии. Следовательно, вся история изменений и вся остальная информация git`a.


## Определение состояния

`git status`

Очень важная команда. Позволяет понять где и в каком состоянии вы находитесь.

![git status](./800.webp)



Состояния файлов:
* неотслеживаемое (untracked);
* измененное (modified);
* подготовленное (staged);
* закомиченное (committed).



## Подготовка файлов


`git add hello.txt`

Добавить файл в отслеживание


`git add -a` или `git add .` 

Добавить в отслеживание все файлы в папке

`git add *.md`

Здесь можно пользоваться регулярными выражениями, чтобы добавлять по какому-то шаблону.


`git diff .\Git_quickguide.md`

Посмотреть изменения

`git reset`
`git reset css/style.css`

изъять ошибочный файл




## Фиксация изменений


`git commit -m 'Add some code'`

Флаг -m это комментарий разработчика. Он необходим для описания зафиксированных изменений. 


## Просмотр коммитов


`git log`

информация о каждом отдельном коммите, с указанием его хэша, автора, списка изменений и даты, когда они были сделаны. Отследить интересующие вас операции в списке изменений, можно по хэшу коммита, при помощи команды git show :

`git log --oneline`

вывод информации о каждом коммите в одну строку с указанием его хэша и комментария. 

`git show hash_commit`

Ну а если вдруг нам нужно переделать commit message и внести туда новый комментарий, можно написать следующую конструкцию:


`git commit --amend -m 'Новый комментарий'`

В данном случае сообщение последнего коммита перезапишется. Но злоупотреблять этим не стоит, поскольку эта операция опасная и лучше ее делать до отправки коммита на сервер.

## Работа с .gitignore

Если мы хотим хранить в репозитории только исходный код и ничего другого надо создать в корневой папке рабочей области специальный файл .gitignore. В этом файле каждая строка будет шаблоном для игнорирования.

Например:

800.webp

*.jpg

*.webp


## Работа с ветками

`git branch -a`

Список всех веток в репозитории 

`git branch dev`

Создание ветки dev от текущего коммита

`git checkout -b dev 1fa3afc`

Создание ветки dev на основе коммита 1fa3afc и переключение на него

`git checkout dev`

Переключение на ветку dev


## Слияние веток и разрешение конфликтов



`git merge dev`

Слияние текущей ветки с dev. Ветка dev вливается в текущую (в нашем случае - в master)

![Процесс слияния веток](512.webp)

### Формат

`git merge <сливаемая ветка>`

#### Ключи

Ключи стратегии слияния.

>Стратегия слияния – это набор правил, которыми руководствуется Git при выполнении слияния.
Существует две основных стратегии слияния:
> * Явное слияние
> * Неявное слияние.

> Их различие заключается в том, что при явном всегда создается новый коммит, а при неявном – используются существующие коммиты.


--ff – включить fast-forward, если это возможно,

--no-ff – отключить fast-forward,

а --ff-only – остановить merge, если его невозможно сделать fast-forward.

--abort

Ключ, использующийся только при разрешении конфликтов. Позволяет прервать слияние и вернуть все к моменту начала операции.

--continue

Ключ, использующийся только при разрешении конфликтов. Позволяет продолжить слияние после разрешения всех конфликтов.


#### Пример

\# Переключимся на основную ветку

$ git checkout master

\# Сольем изменения с ветки draft1 в ветку master

$ git merge draft1

Обновление d078c8d..4a2f9b1

Fast-forward

main.py | 33 +++++++++++++++++++++++++++++++++

README.md | 23 +++++++++++++++++------

bot.py | 6 ++++++

3 files changed, 56 insertions(+), 6 deletions(-)

create mode 100644 main.py

create mode 100644 bot.py

### Явное слияние

Во время явного слияния создается так называемый merge-коммит. Основное предназначение этого коммита состоит в том, чтобы "соединить" изменения двух веток. У этого коммита есть одна особенность: два родительских коммита. Один родитель – последний коммит сливаемой ветки, второй – последний коммит целевой ветки.

Допустим, у нас есть граф вида:
![Граф Git перед слиянием](1_8.png "Граф Git перед слиянием")

То есть у нас есть две ветки: main – основная и develop – ветка для разработки новых функций. 

Выполним команду слияния:

>$ git checkout main

>$ git merge --no-ff develop

Флаг --no-ff в данной ситуации необходим, поскольку надо выполнить явное слияние. 

git merge делает следующие шаги:

1. Проверяет, нет ли конфликтов, т.е. не удалят и не перепишут ли наши изменения какую-либо уже существующую информацию. 
1. Если возникает конфликт git merge останавливается, чтобы получить инструкции от пользователя.
1. Если конфликтов нет, добавляет все изменения из коммитов 3-5 в индекс ветки main.
Делает коммит

После git merge граф репозитория будет выглядеть следующим образом:
![Граф Git после явного слияния](2_9.png "Граф Git после явного слияния")

>#### Полезно знать

>Заметим, что в данном случае (то есть если не возникло конфликтов слияния), git merge эквивалентен командам git checkout develop * и git commit -a "Merge commit "– то есть копированию всех файлов с ветки develop в рабочую копию текущей ветки и последующему созданию коммита.

Коммит Merge commit действительно имеет двух родителей: Commit-5 с ветки develop и Commit-2 c ветки main. Это усложнит откат этого коммита, поэтому будьте предельно внимательны, выполняя git merge.

### Неявное слияние

Во время неявного слияния не создается новых коммитов: используются только уже существующие. Суть этого слияния заключается в том, что из вливаемой ветки извлекаются несколько коммитов, а затем они применяются к последнему коммиту целевой ветки. Такое слияние называется fast-forward.

`$ git checkout main`

`$ git merge develop`

git merge поступит так

1. Проверит, что в ветке main нет коммитов, сделанных после ответвления develop.
2. Проверит, что не возникает конфликтов, если конфликты возникнут, Git попросит пользователя разрешить их.
3. Перенесет указатель main на Commit-5. Теперь ветка develop как бы стала веткой main.

Графически ситуация выглядит следующим образом:
![Граф Git после fast-forward слияния]( 4_8.PNG "Граф Git после fast-forward слияния")

Как видно из рисунка, новый коммит действительно не был создан. Вместо него, Git "подставил" в ветку main уже существующие коммиты из ветки develop.

Стоит подробнее разобрать первый пункт в работе git merge. В нем говорится, что Git проверит, что в ветке main нет коммитов, после ответвления develop. Дело в том, что режим fast-forward возможен не всегда, например в случае такого репозитория:

![Граф Git для которого невозможно выполнить fast-forward слияние](5_7.PNG "Граф Git для которого невозможно выполнить fast-forward слияние")

> Слияние в режиме fast-forward выполнить будет невозможно, поскольку в таком случае мы потеряем всю информацию о Коммите-6. Не будет активных ссылок, указывающих на этот коммит, или одного из его наследников: последующих коммитов, для которых Коммит-6 стал родителем. Поэтому в данном случае придется выполнять явный git merge с созданием merge-коммита.

>#### Полезно знать

>Кстати, по умолчанию git пытается выполнить слияние именно в режиме fast-forward. Поэтому когда мы разбирали явное слияние, нужно было указать флаг --no-ff: без него Git выполнил бы merge в режиме fast-forward.

>#### Подытожим 

>В чем разница между fast-forward и явным слиянием?
>Режим fast-forward считается более удобным, поскольку в нем не нужно создавать лишних merge-коммитов, засоряющих историю репозитория. С другой стороны, если мы продолжим пользоваться веткой develop после fast-forward слияния, потом будет довольно трудно разобраться в ее истории. 

> Так что каждый раз выполняя слияние, задумайтесь, хотите ли вы, чтобы оно прошло в режиме fast-forward, или для вас лучше явно создать merge-коммит, собирающий все воедино.



### Разрешение конфликтов слияния

Очень часто во время слияния веток оказывается, что ваши изменения удаляют или переписывают информацию в уже существующих файлах. Такая ситуация называется файловым конфликтом. Git останавливает выполнение слияния, пока вы не разрешите конфликт.

По сути, Git сталкивается с проблемой: у него есть два файла с одним и тем же именем, и он не знает, какой из них взять. Поэтому обращается к нам за помощью.

Допустим есть следующий репозиторий:
    ![Граф Git-репозитория, в котором мы будем выполнять слияние](6_7.png "Граф Git-репозитория, в котором мы будем выполнять слияние")

    Чтобы не перегружать себя лишней информацией, будем рассматривать всего один файл: Docs.md. Содержимое этого файла в различных коммитах приведено на рисунке, но для удобства продублируем его:

Содержимое Docs.md, C2

*This is documentation*

Содержимое Docs.md, C6

*This is documentation*

*It contains lots of info*

Содержимое Docs.md, C5

*This is documentation*

*New feature info*

*It has lots of info*

Наша задача состоит в том, чтобы слить ветку develop в ветку main.

`$ git merge develop`

Auto-merging Docs.md

CONFLICT (content): Merge conflict in Docs.md

Automatic merge failed; fix conflicts and then commit the result.

Вот так Git и сообщает нам о конфликте: в файле Docs.md из коммита C5 вторая строка переписывает вторую строку фалйа Docs.md из коммита C6. Таким образом Git просит нас разобраться, какой файл оставлять. 

**Общий подход к разрешению конфликтов:**

Непосредственно разрешить конфликт одним из двух рассмотренных ниже способов. 
Либо, если возникновение конфликта стало неожиданным для вас, можно выполнить `git merge --abort`. 

Эта команда прервет слияние и вернет все, как было.

Сообщить Git, что мы разрешили конфликт, добавив все файлы с разрешенными конфликтами в индекс. 

Сделать это можно уже знакомой командой `git add <конфликтный файл>` для каждого конфликтного файла.

Продолжить слияние, выполнив `git merge --continue`. 

Либо вручную создать merge-коммит уже знакомой командой git commit.

**Cуществует два способа разрешать конфликты:**
* Разрешить конфликт вручную. Тогда мы можем самостоятельно изменить конфликтные файлы, сделав их такими, какими мы хотим их видеть.
* Выбрать один из двух файлов.



### Ручное разрешение конфликта

Для этого в любом текстовом редакторе откройте конфликтный файл (если файлов несколько, конфликт нужно устранять в каждом). Приведем содержимое файла **Docs.md**.

 This is documentation

 <<<<<<< HEAD

 It contains lots of info

=======

 New feature info

 It has lots of info

\>>>>>>> develop

Видим, что Git оставил нам пометки, чтобы нам было проще устранять конфликт:

Текст до <<<<<<< HEAD – это общая часть двух файлов, она не конфликтует. В нашем случае оба файла имеют одинаковую первую строку: This is documentation

Текст между <<<<<<< HEAD и ======= – это конфликтующее содержимое файла, на который указывает HEAD, то есть файла из целевой ветки. В нашем случае это вторая строка, именно она переписывается изменениями из ветки develop.

Все, что находится между ======= и >>>>>>> develop – это содержимое файла из ветки develop. В нашем случае это вторая и третья строки:  New feature info и  It has lots of info.

![Файл Docs.md в состоянии конфликта](7_6.png "Файл Docs.md в состоянии конфликта")

Наша задача – объяснить Git, каким мы хотим видеть файл Docs.md. 

Для этого нам нужно вручную отредактировать файл **Docs.md**. 

Нам не обязательно выбирать один из двух приведенных вариантов – в этом вся прелесть ручного редактирования. 

Мы можем удалить вообще весь текст из файла, оставить часть первого файла и часть второго или вообще написать что-то свое. 

Не забудьте удалить строки, которые оставил Git, то есть <<<<<<< HEAD, ======= и >>>>>>>develop, сами собой они не пропадут. 

В качестве примера, мы отредактировали конфликтный файл таким образом:

This is documentation

It contains lots of info

New feature info

### Выбор одного из двух файлов

Если вы точно знаете, что вам нужно оставить только один из двух конфликтных файлов (вся информация из другого файла при этом потеряется), можно сказать об этом Git:

`git checkout --ours Docs.md`, чтобы выбрать файл ветки main (то есть целевой ветки)

Либо `git checkout --their Docs.md`, чтобы выбрать файл из ветки develop (то есть сливаемой ветки).

Эта команда скопирует в docs.md из рабочей копии содержимое одного из конфликтных файлов. 

То есть Git полностью заменит файл в рабочей копии выбранным вами файлом.
Git Bash

\# Разрешим конфликт выбором файла из коммита, к которому мы откатываемся.

$ git checkout --their Docs.md

Updated 1 path from the index

Поздравляю, теперь конфликт разрешен! 
> Кстати, если сейчас выполнить команду git status, нас ждет необычный вывод.

$ git status

On branch main

You have unmerged paths.

  \(fix conflicts and run "git commit")

  \(use "git merge --abort" to abort the merge)


Changes to be committed:

new file:   new_feature.py


Unmerged paths:

  \(use "git add <file>..." to mark resolution)

both modified:   Docs.md

Как видим, Git добавил в индекс файл new_feature.py с ветки develop, поскольку этот файл не вызывал конфликтов. И вместе с тем пометил, что файл Doc s.md находится среди Unmerged paths, то есть Неслитых путей.

Конфликт разрешен, теперь нам осталось только сообщить о разрешении конфликта Git. Сделать это можно командой `git add <filename>` или `git add -A`, чтобы добавить в индекс сразу все файлы, конфликты которых разрешены. 
После этого следует сообщить Git, что мы можем продолжить слияние.

\# Добавим наш файл в индекс.

$ git add Docs.md

\# Ради интереса посмотрим статус

$ git status

On branch main

All conflicts fixed but you are still merging.

\(use "git commit" to conclude merge)

Changes to be committed:

modified:   Docs.md

new file:   new_feature.py

Видим, что Git сообщает нам, что все конфликтыы разрешены. Теперь можно либо вручную выполнить `git commit`, либо написать `git merge --continue`, разницы нет.

Дальше все стандартно: откроется редактор сообщения коммита. В сообщении следует указать, какие ветки вы сливали, и вкратце перечислить внесенные изменения.

\# Продолжим слияние.

$ `git merge --continue`

[main a219fa1] L-04: Merge branch 'develop'

Слияние полностью завершено.
  

### Тонкости разрешения merge-конфликтов.

Теперь мы имеем представление, как разрешать конфликты слияния, и пришло время углубиться в эту тему. Поговорим о тонкостях, которые помогут вам понять, как правильно разрешить конфликт. Подчеркиваем: "правильно", поскольку разрешить конфликт не составляет труда, но если сделать это неверно, можно потерять код, написанный другими разработчиками. 

Допустим, вам дали репозиторий и поставили перед вами задачу: влить ветку **develop** в ветку **main**. Ну хорошо, это мы умеем делать, давайте выполним слияние.


$ git merge develop

Auto-merging colors.txt

CONFLICT (content): Merge conflict in colors.txt

Automatic merge failed; fix conflicts and then commit the result.

Давайте посмотрим на конфликтующий файл в любом текстовом редакторе.

Содержимое файла colors.txt

\<<<<<<< HEAD

This color is red,

And this one is blue.

Check out the base

To make conflict solved by you!

\=======

this color is (255, 36, 0)

and this one is (0, 191, 255)

check out the base

to make conflict solved by you

\>>>>>>> develop

Видно, что файлы различаются, но из этого представления совсем непонятно, что именно должно войти в итоговый файл. 

Если бы это был ваш личный проект, вы бы прекрасно знали, какой из файлов выбрать, но это чужой репозиторий и цена ошибки велика. 

Конечно, можно потратить много времени, перебирая коммиты из обеих веток, разбираясь, как менялись файлы, чтобы понять, что должно быть в итоговом файле. 

Но можно поступить проще. Прежде всего, давайте изучим немного теории.

Итак, при слиянии двух веток используются четыре состояния, и три из них необходимы, чтобы разрешить конфликт правильно. 


Эти состояния можно изобразить на диаграмме следующим образом.

![Четыре состояния слияния](8_6.png "Четыре состояния слияния")

Дельта – это разность каких-то двух состояний. То есть по сути это информация о том, какие изменения вы внесли в файлы с момента определенного коммита. 

Коммиты хранят именно дельты, а не полностью файлы. Благодаря этому репозиторий Git занимает очень мало места.

На диаграмме Дельта-1 – это разность текущего состояния ветки main и базы слияния. 

Аналогично Дельта-2 – это разность текущего состояния ветки develop и базы слияния.

В выводе файла показаны только два состояния. 

На диаграмме они отмечены белым: это текущее состояние ветки main и текущее состояние ветки develop. 

То есть все, что находится между <<<<<<< HEAD и ======= – текущее состояние конфликтного файла в ветке main, и, соответственно, текст между ======= и >>>>>>> develop – состояние конфликтного файла в ветке develop. 

На диаграмме видно еще два состояния – базу слияния и результат слияния. 

Git пытается получить его автоматически, совмещая Дельту-1 и Дельту-2, но если эти дельты задевают одни и те же части одного и того же файла, возникает конфликт. 

При возникновении конфликта Git просит нас сравнить Дельту-1 и Дельту-2, чтобы составить из них третье состояние – результат слияния.

База слияния – это последний общий родитель конфликтных файлов. 

Говоря проще, это тот файл, применив к которому изменения из Дельты-1, мы получим наш файл в ветке develop, а применив изменения из Дельты-2, мы получим наш файл в ветке main. 

Именно база слияния является для нас самым важным состоянием при разрешении конфликта. Мы можем просмотреть ее, и это сильно поможет нам в понимании, какой из файлов нужно оставить.

Чтобы просмотреть базу слияния, нам нужно поменять настройки Git, указав, что мы хотим, чтобы он выводил базу слияния при файловом конфликте. Сделать это можно командой `git 
config`.


$ `git config --global merge.conflictstyle diff3`

Попробуем прервать слияние и снова выполнить его, чтобы Git составил для нас уже новый файл, в котором он отобразит базу слияния.


$ `git merge --abort`

$ `git merge develop`

Содержимое файла colors.txt

\<<<<<<< HEAD

This color is red,

And this one is blue.

Check out the base

To make conflict solved by you!

\||||||| 8b5b982

this color is red

and this one is blue

check out the base

to make conflict solved by you

\=======

this color is (255, 36, 0)

and this one is (0, 191, 255)

check out the base

to make conflict solved by you

\>>>>>>> develop

Видно, что появился новый текст. 

Все, что находится между ||||||| 8b5b982 и ======= – и есть база слияния. 

Иначе говоря, это содержимое файла из общего родителя двух последних коммитов в ветках main и develop. 

Кстати, 16-ричное число в строке ||||||| 8b5b982 – это хэш этого родителя, так что при необходимости можно посмотреть на него в логе репозитория.

В файл в ветке main добавили пунктуационные знаки и заглавные буквы, а в файле в ветке develop названия цветов заменили на их RGB-коды. 

Теперь мы понимаем, что в итоговом файле должны быть заглавные буквы, пунктуационные знаки и RGB-коды вместо привычных цветов. 

Итоговый файл выглядит так:

This color is (255, 36, 0),

And this one is (0, 191, 255).

Check out the base

To make conflict solved by you!

Просмотр базы слияния очень часто помогает понять, как менялись файлы, и как правильно разрешать конфликты в больших репозиториях.

### Инструменты для разрешения merge-конфликтов.
Существует множество графических инструментов для разрешения файловых конфликтов. 

$ `git mergetool`

При запуске программа спросит вас, какой утилитой вы бы хотели воспользоваться. 

Доступные варианты: **meld, opendiff, kdiff3, tkdiff, xxdiff, tortoisemerge, gvimdiff, diffuse, diffmerge, ecmerge, p4merge, araxis, bc, codecompare, smerge, emerge, vimdiff, nvimdif**. 

После выбора утилиты, откроется она сама. 

В ней вы сможете просмотреть подсвеченные изменения в конфликтных файлах в удобном формате, а затем внести необходимые изменения, чтобы разрешить конфликт.

Использование графических утилит особенно удобно при сравнении больших файлов: почти во всех есть подсветка внесенных изменений, что поможет вам не запутаться в файле. 

Тем не менее при сравнении маленьких файлов часто можно обойтись одной консолью. 

Кстати, большинство IDE имеет встроенную утилиту для разрешения конфликтов, что сделает вашу работу с кодом еще более удобной.

